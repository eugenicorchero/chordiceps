<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chordiceps: Entrenador Auditiu d'Acords</title>
    <!-- Càrrega de Tailwind CSS per a un disseny responsive i ràpid -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Configuració de la tipografia i colors professionals */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* Fons fosc molt similar al de la imatge */
            background-color: #0b1122; /* Gairebé negre amb un toc blau fosc */
        }
        /* Estil per al botó de reproducció, per fer-lo destacar */
        #playButton {
            transition: all 0.1s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -2px rgba(0, 0, 0, 0.2);
        }
        /* Utilitzem un ombrejat Blau en l'estat hover */
        #playButton:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.4), 0 4px 6px -4px rgba(37, 99, 235, 0.3); /* blue-600 shadow */
        }
        /* Estil per a la barra de temps */
        #progressBar {
            transition: width 0.9s linear;
        }
        /* Estil per al pop-up d'error d'àudio */
        .audio-error-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 50;
        }
        /* Ombrejat per als botons de dificultat (blau fosc) */
        .difficulty-button {
            background-color: #2563eb; /* Tailwind Blue-600 */
            transition: all 0.15s ease;
            box-shadow: 0 4px 14px 0 rgba(37, 99, 235, 0.5); /* Ombrejat blau intens */
        }
        .difficulty-button:hover {
            background-color: #1d4ed8; /* Tailwind Blue-700 */
        }
        /* Estat inicial de l'app quan l'àudio es carrega */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(11, 17, 34, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 1rem;
            z-index: 60;
            color: white;
            font-size: 1.25rem;
            border-radius: 0.75rem;
            padding: 2rem;
        }
    </style>
</head>

<body class="bg-gray-950 min-h-screen flex flex-col items-center justify-center p-4">

    <!-- POP-UP d'ERROR D'AUDIO -->
    <div id="audioErrorPopup" class="audio-error-popup hidden bg-red-600 text-white p-3 rounded-lg shadow-xl max-w-sm transition duration-300 transform scale-100">
        <p class="font-bold mb-1">⚠️ Error de Precàrrega</p>
        <p id="audioErrorMessage" class="text-sm">No s'han pogut carregar tots els fitxers d'acord.</p>
        <p class="text-xs mt-1 opacity-80">Revisa la nomenclatura de l'arxiu que no es troba.</p>
        <div class="mt-2 flex gap-2">
            <button id="showErrorsBtn" class="bg-white text-red-600 px-3 py-1 rounded">Mostra errors</button>
            <button id="retryErrorsBtn" class="bg-white text-red-600 px-3 py-1 rounded">Reintenta</button>
        </div>
    </div>

    <!-- Contenidor principal de l'aplicació: Fosc i amb ombra subtil -->
    <div id="appContainer" class="bg-gray-800 shadow-2xl rounded-xl w-full max-w-4xl p-8 md:p-12 border border-gray-700/50 mb-4 relative">
        
    <!-- Overlay de càrrega (Visible només quan escollim iniciar preload) -->
    <div id="loadingOverlay" class="loading-overlay hidden">
            <p class="text-center font-semibold">Carregant fitxers d'àudio per a un joc instantani...</p>
            <div class="w-full bg-gray-600 rounded-full h-2.5 max-w-sm">
                <div class="h-2.5 bg-blue-500 rounded-full transition-all duration-300" id="preloaderBar" style="width: 0%"></div>
            </div>
            <p class="text-base text-gray-300" id="preloaderStatus"></p>
        </div>

        <!-- PANTALLA 1: SELECCIÓ DE DIFICULTAT -->
        <div id="difficultyScreen" class="opacity-0 transition-opacity duration-500">
            <header class="text-center mb-8 border-b border-blue-600 pb-4">
                <h1 class="text-4xl font-extrabold text-white tracking-tight">Chordiceps</h1>
                <p class="text-xl text-blue-400 font-semibold mt-1">Entrenador Auditiu d'Acords</p>
            </header>

            <h2 class="text-2xl font-bold text-gray-100 mb-2 text-center">Benvingut/da! Tria el teu Nivell de Pràctica</h2>
            <p class="text-gray-400 text-center mb-8 max-w-xl mx-auto">Practica la identificació d'acords. La fonamental és aleatòria (de C3 a B3), però el tipus d'acord és l'únic que has de reconèixer. Tria el teu nivell.</p>

            <div class="grid md:grid-cols-3 gap-6 max-w-5xl mx-auto">
                <!-- Botons amb el color Blau Fosc -->
                <button onclick="startGame('easy')" class="difficulty-button text-white font-semibold rounded-lg hover:brightness-110 p-6 flex flex-col items-center text-center">
                    <span class="text-xl font-bold mb-2">Fàcil (Tríades Bàsiques)</span>
                    <span class="text-sm opacity-90">Acords: Maj, Men.</span>
                </button>
                <button onclick="startGame('medium')" class="difficulty-button text-white font-semibold rounded-lg hover:brightness-110 p-6 flex flex-col items-center text-center">
                    <span class="text-xl font-bold mb-2">Mitjà (Totes les Tríades)</span>
                    <span class="text-sm opacity-90">Acords: Maj, Men, Aug, Dism.</span>
                </button>
                <!-- Botó Difícil amb la llista completa dels 10 acords -->
                <button onclick="startGame('hard')" class="difficulty-button text-white font-semibold rounded-lg hover:brightness-110 p-6 flex flex-col items-center text-center">
                    <span class="text-xl font-bold mb-2">Difícil (Tots els 10 Acords)</span>
                    <!-- Aquesta etiqueta serà omplerta pel JavaScript a window.onload -->
                    <span id="hardChordsList" class="text-sm opacity-90">Carregant llista d'acords...</span> 
                </button>
            </div>
        </div>

        <!-- PANTALLA 2: JOC / QUIZ -->
        <div id="quizScreen" class="hidden">
            <!-- Puntuació i Temporitzador -->
            <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-4">
                <div class="text-xl font-medium text-gray-300">Ronda: <span id="roundCount" class="font-bold text-blue-400">1</span></div>
                <div class="text-xl font-medium text-gray-300">Puntuació: <span id="score" class="font-bold text-blue-400">0</span></div>
            </div>

            <!-- Àrea de Reproducció i Temporitzador Visual -->
            <div class="text-center mb-8">
                <!-- Botó de reproducció Blau (Sempre actiu per a la repetició) -->
                <button id="playButton" class="bg-blue-600 text-white p-4 rounded-full w-20 h-20 flex items-center justify-center mx-auto mb-4 hover:bg-blue-700 transition duration-200 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed">
                    <!-- Icona de reproducció (SVG) -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                    </svg>
                </button>
                <!-- Label per a l'acord a reconèixer -->
                <p id="directionLabel" class="text-lg font-semibold text-gray-300 mb-4">Reconeix l'Acord</p> 
                <!-- Línia de debug per a la fonamental (oculta per defecte) -->
                <p id="debugNotes" class="hidden text-xs text-gray-500 mb-2"></p> 

                <!-- Barra de progrés del temporitzador (30 segons), utilitzant Blau -->
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 100%"></div>
                </div>
                <p class="text-sm text-gray-400 mt-2">Temps restant per respondre: <span id="timeRemaining">30</span>s</p>
            </div>

            <!-- Botons d'Opció d'Acord (Es generaran per JS) -->
            <div id="intervalOptions" class="grid gap-3 mt-8" style="grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));">
                <!-- Botons injectats aquí -->
            </div>
            
            <!-- Missatge de retroalimentació (Feedback) -->
            <div id="feedbackMessage" class="mt-6 text-center text-lg font-bold min-h-6"></div>

            <!-- Botó de següent ronda (inicialment amagat) -->
            <button id="nextRoundButton" class="hidden w-full py-3 mt-6 bg-gray-700 text-white font-semibold rounded-lg hover:bg-gray-600 transition duration-150 shadow-lg">
                Següent Ronda
            </button>
        </div>

        <!-- PANTALLA 3: RESULTATS FINALS -->
        <div id="resultScreen" class="hidden text-center">
            <h2 class="text-3xl font-bold text-gray-100 mb-4">Resultats Finals</h2>
            <p class="text-xl text-gray-400 mb-6">Has completat la pràctica!</p>
            <p class="text-4xl font-extrabold text-blue-400 mb-8">Puntuació Final: <span id="finalScore">0</span></p>

            <!-- Botó de reset amb color principal (Blau) -->
            <button onclick="resetGame()" class="w-full py-4 px-6 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                Tornar a començar
            </button>
        </div>

    </div>
    
    <!-- Footer/Copyright -->
    <footer class="text-center text-sm text-gray-400 mt-4 max-w-4xl w-full">
        <p>Copyright &copy; Eugeni Corchero 2025 (Adaptat per Chordiceps)</p>
    </footer>


    <!-- LÒGICA JAVASCRIPT -->
    <script>
        // ===============================================
        // VARIABLES GLOBALS I CONFIGURACIÓ (ADAPTAT PER ACORDS)
        // ===============================================

        const AUDIO_PATH = './audios/';
        const MIDI_START = 48; // C3
        const MIDI_END = 59;   // B3
        const TOTAL_MIDI_ROOTS = MIDI_END - MIDI_START + 1;
        const TIMER_DURATION = 30;

        // ABREVIATURES D'ACORD
        const CHORD_ABBREVIATIONS = {
            'Maj': 'Maj', 'Men': 'Men', 'Aug': 'Aug', 'Dim': 'Dism',
            'Maj7': 'Maj 7', 'Dom7': 'Dom 7', 'Men7': 'Men 7', 'm7b5': 'm7b5', 'Dim7': 'Dism 7', 'AugM7': 'Aug M7'
        };
        const ALL_CHORDS = Object.keys(CHORD_ABBREVIATIONS);
        const CHORD_DISPLAY_ORDER = ['Maj','Men','Aug','Dim','AugM7','Maj7','Men7','Dom7','m7b5','Dim7'];

        const DIFFICULTY_CONFIG = {
            easy: { chords: ['Maj','Men'] },
            medium: { chords: ['Maj','Men','Aug','Dim'] },
            hard: { chords: ALL_CHORDS }
        };

        // Detectem dispositiu mòbil per ajustar concurrència i mida de cache
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/.test(navigator.userAgent) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);

    // Create a shared AudioContext early so we can decode audio buffers and play via WebAudio
    const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;

    // Register a lightweight service worker (in-page blob) to cache audio files and serve them cache-first.
    (function registerSW(){
        if (!('serviceWorker' in navigator)) return;
        try {
            const swCode = `
            self.addEventListener('install', e => { self.skipWaiting(); });
            self.addEventListener('activate', e => { self.clients.claim(); });
            self.addEventListener('fetch', event => {
                try {
                    const url = new URL(event.request.url);
                    if (url.pathname.includes('/audios/')) {
                        event.respondWith(caches.open('audio-cache-v1').then(async cache => {
                            const cached = await cache.match(event.request);
                            if (cached) {
                                // update in background
                                fetch(event.request).then(res => { if (res && res.ok) cache.put(event.request, res.clone()); }).catch(()=>{});
                                return cached;
                            }
                            const res = await fetch(event.request);
                            if (res && res.ok) cache.put(event.request, res.clone());
                            return res;
                        }));
                    }
                } catch(e) { /* ignore */ }
            });
            `;

            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);
            navigator.serviceWorker.register(swUrl, { scope: './' }).then(reg => {
                // console.log('SW registered', reg);
            }).catch(() => {
                // ignore failures (e.g., insecure context)
            });
        } catch(e) {}
    })();

        // DOM refs
        const screens = {
            difficulty: document.getElementById('difficultyScreen'),
            quiz: document.getElementById('quizScreen'),
            result: document.getElementById('resultScreen')
        };
        const elements = {
            roundCount: document.getElementById('roundCount'),
            score: document.getElementById('score'),
            playButton: document.getElementById('playButton'),
            progressBar: document.getElementById('progressBar'),
            timeRemaining: document.getElementById('timeRemaining'),
            intervalOptions: document.getElementById('intervalOptions'),
            feedbackMessage: document.getElementById('feedbackMessage'),
            nextRoundButton: document.getElementById('nextRoundButton'),
            directionLabel: document.getElementById('directionLabel'),
            finalScore: document.getElementById('finalScore'),
            audioErrorPopup: document.getElementById('audioErrorPopup'),
            audioErrorMessage: document.getElementById('audioErrorMessage'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            preloaderBar: document.getElementById('preloaderBar'),
            preloaderStatus: document.getElementById('preloaderStatus'),
            debugNotes: document.getElementById('debugNotes'),
            hardChordsList: document.getElementById('hardChordsList')
        };

        // Estat del joc
        let gameState = {
            difficulty: null,
            score: 0,
            round: 0,
            correctChordType: null,
            timer: null,
            timeRemaining: TIMER_DURATION,
            isAnswered: false,
            baseNoteMIDI: null,
            currentChordLabel: null,
            isAudioReady: false
        };

        // -----------------------------------------------
        // AudioLoader: LRU cache + staged preload + on-demand
        // -----------------------------------------------
        class AudioLoader {
            constructor(options = {}) {
                this.audioPath = options.audioPath || AUDIO_PATH;
                this.concurrency = options.concurrency || (isMobile ? 3 : 8);
                this.maxCacheSize = options.maxCacheSize || (isMobile ? 64 : 200);
                this.cache = new Map(); // key -> HTMLAudioElement
                this.loading = new Map(); // key -> Promise
                this.failedUrls = new Set();
            }

            fileKey(midi, chord) { return `${midi}-${chord}`; }

            fileUrl(midi, chord) {
                const fileNotesMap = ['C','Cs','D','Ds','E','F','Fs','G','Gs','A','As','B'];
                const octave = Math.floor(midi / 12) - 1;
                const noteIndex = midi % 12;
                const root = fileNotesMap[noteIndex] + octave;
                return `${this.audioPath}${root}-${chord}.mp3`;
            }

            // Promou una clau com a recent (LRU)
            promote(key) {
                if (!this.cache.has(key)) return;
                const v = this.cache.get(key);
                this.cache.delete(key);
                this.cache.set(key, v);
            }

            // Evict si cal
            ensureCacheLimit() {
                while (this.cache.size > this.maxCacheSize) {
                    const oldestKey = this.cache.keys().next().value;
                    const audio = this.cache.get(oldestKey);
                    try { if (audio && audio.src && audio.src.startsWith('blob:')) URL.revokeObjectURL(audio.src); } catch(e) {}
                    this.cache.delete(oldestKey);
                }
            }

            isLoadedKey(key) { return this.cache.has(key); }

            getIfLoaded(key) { return this.cache.get(key); }

            // Carrega un fitxer i retorna Promise que resol amb l'element Audio
            loadOne(midi, chord) {
                const key = this.fileKey(midi, chord);
                if (this.cache.has(key)) {
                    this.promote(key);
                    return Promise.resolve(this.cache.get(key));
                }
                if (this.loading.has(key)) return this.loading.get(key);

                const url = this.fileUrl(midi, chord);
                // Try a quick HEAD check (short timeout) to fail fast on 404s/network issues.
                const p = new Promise((resolve) => {
                    const controller = new AbortController();
                    const headTimeout = setTimeout(() => controller.abort(), 4000);

                    fetch(url, { method: 'HEAD', signal: controller.signal }).then(resp => {
                        clearTimeout(headTimeout);
                        // If server responds OK-ish, proceed to create audio. If server replies 4xx/5xx, fail early.
                        if (resp && resp.ok) {
                            createAudioElement();
                        } else {
                            // Some servers don't support HEAD (405) - still try audio element unless explicit 4xx/5xx
                            if (resp && (resp.status >= 400 && resp.status < 600)) {
                                this.failedUrls.add(url);
                                resolve({ key, audio: null, ok: false, url });
                            } else {
                                createAudioElement();
                            }
                        }
                    }).catch(() => {
                        clearTimeout(headTimeout);
                        // HEAD failed (network or CORS), fall back to trying Audio element - it may still load
                        createAudioElement();
                    });

                    const createAudioElement = () => {
                                // Fetch the audio as blob - this will populate the SW cache if available
                                fetch(url).then(resp => {
                                    if (!resp || !resp.ok) throw new Error('fetch failed');
                                    return resp.blob();
                                }).then(blob => {
                                    const objectUrl = URL.createObjectURL(blob);
                                    const audio = new Audio();
                                    audio.preload = 'auto';
                                    audio.src = objectUrl;

                                    const clean = () => {
                                        audio.oncanplaythrough = null;
                                        audio.onerror = null;
                                    };

                                    audio.oncanplaythrough = () => {
                                        clean();
                                        this.cache.set(key, audio);
                                        this.promote(key);
                                        this.ensureCacheLimit();
                                        this.loading.delete(key);
                                        resolve({ key, audio, ok: true, url });
                                    };
                                    audio.onerror = () => {
                                        clean();
                                        this.loading.delete(key);
                                        this.failedUrls.add(url);
                                        try { URL.revokeObjectURL(objectUrl); } catch(e) {}
                                        resolve({ key, audio: null, ok: false, url });
                                    };
                                    try { audio.load(); } catch(e) { this.failedUrls.add(url); resolve({ key, audio: null, ok: false, url }); }
                                }).catch(() => {
                                    this.loading.delete(key);
                                    this.failedUrls.add(url);
                                    resolve({ key, audio: null, ok: false, url });
                                });
                    };
                });

                this.loading.set(key, p);
                return p;
            }

            // Precarrega suggerida per al nivell de dificultat.
            // Strategy: carregar ràpidament una petita llista de fonamentals (initialRoots) per a un arranc ràpid,
            // després continuar en background amb la resta. Retorna Promise que resol quan l'etapa inicial està carregada.
            preloadForDifficulty(difficulty, opts = {}) {
                const chords = (DIFFICULTY_CONFIG[difficulty] || DIFFICULTY_CONFIG.easy).chords;
                const onProgress = opts.onProgress || function () {};
                const total = chords.length * TOTAL_MIDI_ROOTS;

                // Determine staged loading size
                const initialRoots = opts.initialRoots || (isMobile ? 4 : 8);

                // Build list of all items
                const allRoots = [];
                for (let m = MIDI_START; m <= MIDI_END; m++) allRoots.push(m);

                // Initial roots: take spread across the set for variety
                const step = Math.max(1, Math.floor(allRoots.length / initialRoots));
                const initialRootSet = allRoots.filter((_, idx) => idx % step === 0).slice(0, initialRoots);

                const initialList = [];
                const remainingList = [];

                allRoots.forEach(midi => {
                    chords.forEach(chord => {
                        const item = { midi, chord };
                        if (initialRootSet.includes(midi)) initialList.push(item); else remainingList.push(item);
                    });
                });

                let loaded = 0; let failed = 0; const failedUrls = [];

                const update = () => onProgress({ loaded, totalInitial: initialList.length, totalAll: total, failed });

                // Helper to run limited concurrency on an array
                const runQueue = (items, concurrencyOverride, reportEach = true) => {
                    return new Promise(resolve => {
                        let i = 0; let active = 0;
                        const next = () => {
                            if (i >= items.length && active === 0) return resolve();
                            const concurrencyToUse = concurrencyOverride || this.concurrency;
                            while (active < concurrencyToUse && i < items.length) {
                                const it = items[i++]; active++;
                                this.loadOne(it.midi, it.chord).then(res => {
                                    active--;
                                    if (!res.ok) { failed++; failedUrls.push(res.url); }
                                    loaded++;
                                    if (reportEach) update();
                                    setTimeout(next, 0);
                                });
                            }
                        };
                        next();
                    });
                };

                // 1) Load initialList with moderate concurrency
                return new Promise(async (resolve) => {
                    await runQueue(initialList, opts.concurrency || Math.max(1, Math.floor(this.concurrency / 2)));
                    // initial stage done
                    update();
                    // Resolve so the app can start quickly
                    resolve({ initialLoaded: true, failed, failedUrls });
                    // 2) background load remaining (low concurrency, spaced)
                    (async () => {
                        // small delay to avoid blocking main thread/network
                        await new Promise(r => setTimeout(r, 300));
                        await runQueue(remainingList, opts.backgroundConcurrency || Math.max(1, Math.floor(this.concurrency / 3)), true);
                        // final update
                        update();
                        // After background pass, schedule an automatic retry for failed URLs
                        setTimeout(() => {
                            try { retryFailedUrls(); } catch(e) {}
                        }, 8000);
                    })();
                });
            }

            // On-demand get: returns a Promise that resolves to audio element (loads if needed)
            getAudio(midi, chord) {
                const key = this.fileKey(midi, chord);
                if (this.cache.has(key)) {
                    this.promote(key);
                    return Promise.resolve(this.cache.get(key));
                }
                return this.loadOne(midi, chord).then(res => res.ok ? res.audio : Promise.reject(new Error('load failed')));
            }
        }

        // Instància global
        const audioLoader = new AudioLoader({ audioPath: AUDIO_PATH, concurrency: isMobile ? 3 : 8, maxCacheSize: isMobile ? 80 : 300 });

        // -----------------------------------------------
        // Utils d'àudio i integració amb la UI
        // -----------------------------------------------
        function showAudioErrorPopup(message) {
            elements.audioErrorMessage.textContent = message;
            elements.audioErrorPopup.classList.remove('hidden');
            setTimeout(() => elements.audioErrorPopup.classList.add('hidden'), 15000);
        }

        function getRootName(midiNumber) {
            const notesMap = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
            const octave = Math.floor(midiNumber / 12) - 1;
            return `${notesMap[midiNumber % 12]}${octave}`;
        }

        // Reproduir acord (assegura cargar si cal)
        async function playChord() {
            const midi = gameState.baseNoteMIDI;
            const chord = gameState.correctChordType;
            if (!midi || !chord) return;

            try {
                const audio = await audioLoader.getAudio(midi, chord);
                audio.pause(); audio.currentTime = 0;
                const p = audio.play();
                if (p && p.catch) p.catch(e => {
                    if (e.name === 'NotAllowedError') elements.feedbackMessage.textContent = '🔊 Fes clic a Play per permetre àudio.';
                });
            } catch (e) {
                elements.feedbackMessage.textContent = '🔊 Àudio no disponible (s’està intentant carregar). Reproduint fallback sintètic.';
                // Log failed URL for later inspection
                try { localStorage.setItem('chordiceps_failed_urls', JSON.stringify(Array.from(audioLoader.failedUrls || []))); } catch(_) {}
                // Play synthesized fallback so the game remains playable
                try { playSynthChord(midi, chord); } catch(_) {}
            }
        }

    // -----------------------
    // WebAudio fallback synth
    // -----------------------

        // Map chord type to semitone intervals (basic approximations)
        const CHORD_INTERVALS = {
            'Maj': [0, 4, 7],
            'Men': [0, 3, 7],
            'Aug': [0, 4, 8],
            'Dim': [0, 3, 6],
            'Maj7': [0, 4, 7, 11],
            'Dom7': [0, 4, 7, 10],
            'Men7': [0, 3, 7, 10],
            'm7b5': [0, 3, 6, 10],
            'Dim7': [0, 3, 6, 9],
            'AugM7': [0, 4, 8, 11]
        };

        function midiToFreq(m) {
            return 440 * Math.pow(2, (m - 69) / 12);
        }

        function playSynthChord(rootMidi, chordType, duration = 2.0) {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const intervals = CHORD_INTERVALS[chordType] || CHORD_INTERVALS['Maj'];
            const gainMaster = audioCtx.createGain();
            gainMaster.gain.setValueAtTime(0.0001, now);
            gainMaster.connect(audioCtx.destination);
            // envelope
            gainMaster.gain.exponentialRampToValueAtTime(0.6, now + 0.02);
            gainMaster.gain.exponentialRampToValueAtTime(0.001, now + duration);

            intervals.forEach((interval, idx) => {
                const osc = audioCtx.createOscillator();
                const detuneOsc = audioCtx.createOscillator();
                const oscGain = audioCtx.createGain();
                osc.type = (idx === 0) ? 'sawtooth' : 'sine';
                const freq = midiToFreq(rootMidi + interval);
                osc.frequency.setValueAtTime(freq, now);
                // slight detune for richness
                osc.detune.setValueAtTime((idx - 1) * 5, now);
                oscGain.gain.setValueAtTime(1 / (intervals.length), now);
                osc.connect(oscGain);
                oscGain.connect(gainMaster);
                osc.start(now + 0.01);
                osc.stop(now + duration);
            });
        }

        // -----------------------------------------------
        // Lògica del joc (lleugeres adaptacions per usar audioLoader)
        // -----------------------------------------------
        function initializeHardChordsList() {
            const chordLabels = DIFFICULTY_CONFIG.hard.chords.map(k => CHORD_ABBREVIATIONS[k]);
            elements.hardChordsList.textContent = `Acords: ${chordLabels.join(', ')}`;
        }

        function showScreen(screenId) {
            Object.values(screens).forEach(s => s.classList.add('hidden'));
            screens[screenId].classList.remove('hidden');
        }

        // Quan l'usuari tria dificultat: preparem la preload escalonada i mostrem la pantalla de quiz quan l'etapa inicial estigui llesta
        function startGame(difficulty) {
            if (!DIFFICULTY_CONFIG[difficulty]) return console.error('Dificultat no reconeguda', difficulty);
            gameState.difficulty = difficulty;
            gameState.score = 0; gameState.round = 0; elements.score.textContent = '0';

            // Mostrem overlay i iniciem preload suggerida
            elements.loadingOverlay.classList.remove('hidden');
            elements.preloaderBar.style.width = '0%';
            elements.preloaderStatus.textContent = 'Preparant àudios...';

            audioLoader.preloadForDifficulty(difficulty, {
                initialRoots: (difficulty === 'hard') ? (isMobile ? 6 : 12) : (isMobile ? 4 : 8),
                concurrency: (difficulty === 'hard') ? (isMobile ? 2 : 6) : undefined,
                backgroundConcurrency: (difficulty === 'hard') ? (isMobile ? 1 : 3) : undefined,
                onProgress: ({ loaded, totalInitial, totalAll, failed }) => {
                    // show progress relative to initial stage first, then overall
                    const pct = Math.round((loaded / Math.max(1, totalInitial)) * 100);
                    elements.preloaderBar.style.width = `${Math.min(100, pct)}%`;
                    elements.preloaderStatus.textContent = `Carregats ${loaded}/${totalInitial} (inicial). Errors: ${failed} (fails: ${audioLoader.failedUrls.size})`;
                }
            }).then(({ failed, failedUrls } = {}) => {
                gameState.isAudioReady = true;
                elements.loadingOverlay.classList.add('hidden');
                showScreen('quiz');
                loadNextRound();
            }).catch(e => {
                gameState.isAudioReady = false;
                elements.loadingOverlay.classList.add('hidden');
                showAudioErrorPopup('No s\'han pogut carregar alguns àudios. El joc intentarà carregar sota demanda. Errors totals: ' + audioLoader.failedUrls.size);
                showScreen('quiz');
                loadNextRound();
            });
        }

        // Generate a random chord (no blocking cache checks here)
        function generateChord() {
            const availableChords = DIFFICULTY_CONFIG[gameState.difficulty].chords;
            const chordType = availableChords[Math.floor(Math.random() * availableChords.length)];
            const rootMIDI = Math.floor(Math.random() * (MIDI_END - MIDI_START + 1)) + MIDI_START;
            return { correctChordType: chordType, baseNoteMIDI: rootMIDI, label: CHORD_ABBREVIATIONS[chordType] };
        }

        async function loadNextRound() {
            gameState.round++; gameState.isAnswered = false;
            elements.feedbackMessage.textContent = '';
            elements.feedbackMessage.className = 'mt-6 text-center text-lg font-bold min-h-6';
            elements.nextRoundButton.classList.add('hidden');
            elements.roundCount.textContent = gameState.round;

            const newChord = generateChord();
            gameState.correctChordType = newChord.correctChordType;
            gameState.baseNoteMIDI = newChord.baseNoteMIDI;
            gameState.currentChordLabel = newChord.label;

            elements.playButton.disabled = !gameState.isAudioReady;
            elements.playButton.classList.remove('opacity-50');

            elements.directionLabel.textContent = `Reconeix l'Acord (Fonamental: ${getRootName(gameState.baseNoteMIDI)})`;

            const optionsToUse = DIFFICULTY_CONFIG[gameState.difficulty].chords;
            generateOptions(optionsToUse);
            startTimer();

            // Intentem carregar sota demanda si no existeix encara
            const midi = gameState.baseNoteMIDI;
            const chord = gameState.correctChordType;
            const key = `${midi}-${chord}`;
            if (!audioLoader.isLoadedKey(key)) {
                elements.feedbackMessage.textContent = '🔄 Carregant àudio...';
                try {
                    // intent amb timeout (5s) i 1 retry
                    await Promise.race([
                        audioLoader.getAudio(midi, chord),
                        new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), 5000))
                    ]);
                } catch (e) {
                    // retry once quickly
                    try { await audioLoader.getAudio(midi, chord); } catch (e2) { elements.feedbackMessage.textContent = '⚠️ Àudio no disponible per a aquesta ronda.'; }
                }
            }

            if (gameState.isAudioReady) playChord();
        }

        function generateOptions(availableOptions) {
            elements.intervalOptions.innerHTML = '';
            const orderedOptions = CHORD_DISPLAY_ORDER.filter(k => availableOptions.includes(k));
            const buttonsData = orderedOptions.map(key => ({ key, label: CHORD_ABBREVIATIONS[key] }));
            buttonsData.forEach(chord => {
                const button = document.createElement('button');
                button.textContent = chord.label;
                button.setAttribute('data-chord-type', chord.key);
                button.onclick = () => checkAnswer(chord.key, button);
                button.classList.add('py-3','px-4','bg-gray-700','text-gray-100','font-semibold','rounded-lg','shadow-sm','hover:bg-blue-600','hover:text-white','transition','duration-150','text-sm','md:text-base');
                elements.intervalOptions.appendChild(button);
            });
            const numOptions = availableOptions.length;
            let gridLayout = 'repeat(auto-fit, minmax(120px, 1fr))';
            if (numOptions > 8) gridLayout = 'repeat(auto-fit, minmax(100px, 1fr))';
            elements.intervalOptions.style.gridTemplateColumns = gridLayout;
        }

        function checkAnswer(selectedChordType, selectedButton) {
            if (gameState.isAnswered) return;
            clearInterval(gameState.timer); gameState.isAnswered = true;
            const isCorrect = selectedChordType === gameState.correctChordType;
            Array.from(elements.intervalOptions.children).forEach(btn => {
                btn.disabled = true; btn.classList.remove('hover:bg-blue-600','bg-gray-700'); btn.classList.add('cursor-not-allowed','opacity-80');
                const currentChordType = btn.getAttribute('data-chord-type');
                if (currentChordType === gameState.correctChordType) btn.classList.add('bg-green-500','text-white','font-bold');
                else if (btn === selectedButton) btn.classList.add('bg-red-500','text-white','font-bold');
            });
            if (isCorrect) { gameState.score++; elements.score.textContent = gameState.score; elements.feedbackMessage.textContent = '✅ Correcte! Acord: ' + gameState.currentChordLabel; elements.feedbackMessage.classList.add('text-green-400'); }
            else { elements.feedbackMessage.textContent = '❌ Incorrecte. La resposta era: ' + gameState.currentChordLabel; elements.feedbackMessage.classList.add('text-red-400'); }
            elements.nextRoundButton.classList.remove('hidden');
        }

        function startTimer() {
            gameState.timeRemaining = TIMER_DURATION; elements.timeRemaining.textContent = TIMER_DURATION; elements.progressBar.style.width = '100%';
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(() => {
                gameState.timeRemaining--; elements.timeRemaining.textContent = gameState.timeRemaining;
                const percentage = (gameState.timeRemaining / TIMER_DURATION) * 100; elements.progressBar.style.width = `${percentage}%`;
                elements.progressBar.classList.remove('bg-red-500','bg-blue-600');
                if (gameState.timeRemaining <= 10) elements.progressBar.classList.add('bg-red-500'); else elements.progressBar.classList.add('bg-blue-600');
                if (gameState.timeRemaining <= 0) {
                    clearInterval(gameState.timer);
                    if (!gameState.isAnswered) {
                        elements.feedbackMessage.textContent = '⏱️ Temps esgotat! La resposta era: ' + gameState.currentChordLabel;
                        elements.feedbackMessage.classList.add('text-red-400'); elements.nextRoundButton.classList.remove('hidden'); gameState.isAnswered = true;
                        Array.from(elements.intervalOptions.children).forEach(btn => { if (btn.getAttribute('data-chord-type') === gameState.correctChordType) btn.classList.add('bg-green-500','text-white','font-bold'); btn.disabled = true; btn.classList.add('cursor-not-allowed','opacity-80'); });
                    }
                }
            }, 1000);
        }

        function endGame() { clearInterval(gameState.timer); elements.finalScore.textContent = gameState.score; showScreen('result'); }
        function resetGame() { clearInterval(gameState.timer); showScreen('difficulty'); gameState.score = 0; gameState.round = 0; }

        // Inicialització
        window.onload = function() {
            elements.playButton.onclick = playChord;
            elements.nextRoundButton.onclick = () => { const MAX_ROUNDS = 20; if (gameState.round >= MAX_ROUNDS) endGame(); else loadNextRound(); };
            initializeHardChordsList();
            // Mostrem pantalla de dificultat
            screens.difficulty.classList.remove('opacity-0');

            // Hook up error popup buttons
            const showErrorsBtn = document.getElementById('showErrorsBtn');
            const retryErrorsBtn = document.getElementById('retryErrorsBtn');
            if (showErrorsBtn) showErrorsBtn.onclick = () => {
                const arr = Array.from(audioLoader.failedUrls || []);
                alert('Failed URLs:\n' + (arr.slice(0,50).join('\n')) + (arr.length > 50 ? `\n... +${arr.length-50} more` : ''));
            };
            if (retryErrorsBtn) retryErrorsBtn.onclick = () => {
                retryFailedUrls();
            };
        };

        // Retry logic: parse failed URLs and attempt to reload them with low concurrency / backoff
        function parseUrlToParts(url) {
            try {
                const file = url.split('/').pop(); // e.g. Cs3-Maj.mp3
                const [name] = file.split('.');
                const dash = name.indexOf('-');
                const root = name.slice(0, dash);
                const chord = name.slice(dash+1);
                // Convert root back to midi: simple parse assuming last char is octave
                const m = root.match(/^([A-G]s?)(-?\d+)$/);
                if (!m) return null;
                const note = m[1]; const octave = parseInt(m[2], 10);
                const fileNotesMap = {C:0, Cs:1, D:2, Ds:3, E:4, F:5, Fs:6, G:7, Gs:8, A:9, As:10, B:11};
                if (!(note in fileNotesMap)) return null;
                const midi = (octave + 1) * 12 + fileNotesMap[note];
                return { midi, chord };
            } catch(e) { return null; }
        }

        async function retryFailedUrls() {
            const arr = Array.from(audioLoader.failedUrls || []);
            if (!arr.length) { alert('No failed URLs to retry'); return; }
            elements.preloaderStatus.textContent = `Reintentant ${arr.length} fitxers...`;
            // Attempt sequentially with small delay
            for (let i=0;i<arr.length;i++) {
                const url = arr[i];
                const parts = parseUrlToParts(url);
                if (!parts) continue;
                try {
                    await audioLoader.getAudio(parts.midi, parts.chord);
                    // remove from failed set
                    audioLoader.failedUrls.delete(url);
                } catch(e) {
                    // keep in failed set
                }
                await new Promise(r => setTimeout(r, 300));
            }
            localStorage.setItem('chordiceps_failed_urls', JSON.stringify(Array.from(audioLoader.failedUrls || [])));
            alert('Reintents finalitzats. Errors restants: ' + (audioLoader.failedUrls.size || 0));
        }
    </script>


    
</body>
</html>

